/////////////////////////////////////////////////////////////////////////////////
//
// NEngine C++ Library
// Copyright (c) 2017-2017 Sebastian Netsch
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
/////////////////////////////////////////////////////////////////////////////////

#ifndef __NENGINE__NSTATE_MANAGER__NSTATE_MANAGER__
#define __NENGINE__NSTATE_MANAGER__NSTATE_MANAGER__

/////////////////////////////////////////////////////////////////////////////////
// ! memory for shared pointers
// ! mutex for thread safety
// ! stack for the state stack
// ! nstate for managing different states
/////////////////////////////////////////////////////////////////////////////////
#include <memory>
#include <mutex>
#include <stack>
#include "nstate.hpp"

/////////////////////////////////////////////////////////////////////////////////
// ! namespace for the nengine
/////////////////////////////////////////////////////////////////////////////////
namespace nengine {

/////////////////////////////////////////////////////////////////////////////////
// ! namespace for the nstate_manager
/////////////////////////////////////////////////////////////////////////////////
namespace nstate_manager {

/////////////////////////////////////////////////////////////////////////////////
// ! namespace using for easier and cleaner programming
/////////////////////////////////////////////////////////////////////////////////
using namespace nengine;
using namespace nengine::nstate_manager;

/////////////////////////////////////////////////////////////////////////////////
// ! the nstate_manager
/////////////////////////////////////////////////////////////////////////////////
class nstate_manager
{
	public:
		/////////////////////////////////////////////////////////////////////////////////
		// ! delete default constructor
		/////////////////////////////////////////////////////////////////////////////////
		nstate_manager(const nstate_manager&) = delete;
		/////////////////////////////////////////////////////////////////////////////////
		// ! delete copy constructor
		/////////////////////////////////////////////////////////////////////////////////
		nstate_manager& operator=(const nstate_manager&) = delete;
		/////////////////////////////////////////////////////////////////////////////////
		// ! custom constructor: with initialization list
		/////////////////////////////////////////////////////////////////////////////////
		nstate_manager()
			: _mutex()
			, _states()
			, _state()
			, _removing(false)
			, _adding(false)
			, _replacing(false)
		{
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! custom destructor: clears the internal stack thread safe
		/////////////////////////////////////////////////////////////////////////////////
		~nstate_manager()
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				while(!_states.empty())
					_states.pop();
			} // lock freed
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! adds a state
		// @param1: the state to add
		// @param2: to indicate if the state is replacing the current state
		/////////////////////////////////////////////////////////////////////////////////
		auto add(std::unique_ptr<nstate> state, bool replacing) -> void
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				_adding = true;
				_replacing = replacing;
				_state = std::move(state);
			} // lock freed
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! removes a state
		/////////////////////////////////////////////////////////////////////////////////
		auto remove() -> void
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				_removing = true;
			} // lock freed
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! processes all changes made to the nstate_manager with add() && remove()
		/////////////////////////////////////////////////////////////////////////////////
		auto process() -> void
		{
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				if((_removing) && (!_states.empty()))
				{
					_states.pop();
					if(!_states.empty())
					{
						_states.top()->resume();
					}
					_removing = false;
				}
				if(_adding)
				{
					if(!_states.empty())
					{
						if(_replacing)
						{
							_states.pop();
						}
						else
						{
							_states.top()->pause();
						}
					}
					_states.push(std::move(_state));
					_states.top()->init();
					_adding = false;
				}
			} // lock freed
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! processes all changes made to the nstate_manager with add() && remove()
		// @return: true if a state was removed
		/////////////////////////////////////////////////////////////////////////////////
		auto if_process() -> bool
		{
			bool clr = false;
			std::unique_lock<std::mutex> lock(_mutex);
			{ // locked area
				if((_removing) && (!_states.empty()))
				{
					clr = true;
					_states.pop();
					if(!_states.empty())
					{
						_states.top()->resume();
					}
					_removing = false;
				}
				if(_adding)
				{
					if(!_states.empty())
					{
						if(_replacing)
						{
							clr = true;
							_states.pop();
						}
						else
						{
							_states.top()->pause();
						}
					}
					_states.push(std::move(_state));
					_states.top()->init();
					_adding = false;
				}
			} // lock freed
			return clr;
		}
		/////////////////////////////////////////////////////////////////////////////////
		// ! returns the current state
		// @return: a unique pointer to the current state
		/////////////////////////////////////////////////////////////////////////////////
		auto get() -> std::unique_ptr<nstate>&
		{
			return _states.top();
		}
	private:
		/////////////////////////////////////////////////////////////////////////////////
		// ! for thread safety
		/////////////////////////////////////////////////////////////////////////////////
		std::mutex _mutex;
		/////////////////////////////////////////////////////////////////////////////////
		// ! all states
		/////////////////////////////////////////////////////////////////////////////////
		std::stack<std::unique_ptr<nstate>> _states;
		/////////////////////////////////////////////////////////////////////////////////
		// ! last state
		/////////////////////////////////////////////////////////////////////////////////
		std::unique_ptr<nstate> _state;
		/////////////////////////////////////////////////////////////////////////////////
		// ! if you are removing a state
		/////////////////////////////////////////////////////////////////////////////////
		bool _removing;
		/////////////////////////////////////////////////////////////////////////////////
		// ! if you are adding a state
		/////////////////////////////////////////////////////////////////////////////////
		bool _adding;
		/////////////////////////////////////////////////////////////////////////////////
		// ! if new state is replacing the old one
		/////////////////////////////////////////////////////////////////////////////////
		bool _replacing;
}; // end of class nstate_manager

} // end of namespace nstate_manager

} // end of namespace nengine

#endif // end of __NENGINE__NSTATE_MANAGER__NSTATE_MANAGER__

